Skilltree Orthogonal Link Routing Plan
======================================

Plan-ID: SKILLTREE_ORTHOGONAL_LINK_ROUTING_PLAN

Status
- Current: NOT_STARTED
- Last Reviewed: 2026-02-14
- Owner: @hanzen (claimed 2026-02-14)
- Notes: Skill dependencies currently render as straight center-to-center vectors; target behavior is right-angle, grid-following "snake" paths.

Goal
- Replace direct vector dependency arrows with orthogonal, grid-constrained paths in the skilltree view.
- Keep link routing deterministic, readable, and stable across camera pan/zoom.
- Preserve current unlock logic and editor interaction behavior while upgrading visual pathing.

Dependencies
- Uses existing skilltree graph data in `game/src/skilltree.rs` (`requires` relationships).
- Must integrate with current skilltree render pipeline in `game/src/tetris_ui.rs`.
- Must not regress skilltree click/drag/zoom interactions in `game/src/bin/headful/main.rs`.

Non-Goals
- No gameplay/meta progression rule changes.
- No immediate persistence/schema changes for manually authored edge routes in v1.
- No broad UI redesign outside skilltree dependency link rendering.

Design Rules / Constraints
- Route in world grid coordinates first; convert to pixels only during draw.
- Paths are Manhattan only (horizontal/vertical segments), with 90-degree turns.
- Route output must be deterministic for a given graph/layout.
- Avoid pathing through occupied node cells except explicit source/target ports.
- Keep implementation localized; avoid unrelated refactors.
- Prefer pure routing helpers that are unit-testable without renderer dependencies.

Current Baseline (for reference)
- Link draw entry point: `draw_skilltree_links(...)` in `game/src/tetris_ui.rs`.
- Current primitive: `draw_arrow(...)` draws straight lines from source center to target center.
- Existing test coverage: `draw_skilltree_draws_dependency_arrows` in `game/tests/tetris_ui_tests.rs`.

Routing Strategy (v1)
- Build a world-space occupancy map from all node shape cells.
- For each dependency edge `req -> node`:
  - Choose source and target boundary ports (node perimeter-adjacent cells).
  - Run orthogonal pathfinding (A* on 4-neighbor grid) between ports.
  - Use Manhattan heuristic, step cost, and turn penalty to favor smoother routes.
  - Optionally add soft overlap penalty to reduce edge stacking.
- If no valid route is found:
  - Fall back to a simple orthogonal dogleg route (still no diagonal segment draw).
  - If dogleg cannot avoid occupancy, allow constrained overlap with existing links rather than failing to draw.

Execution Checklist
- [ ] Phase 1: add world-space link geometry helpers (occupancy, ports, world->screen conversion).
- [ ] Phase 2: implement deterministic orthogonal router (A*) with turn-aware scoring.
- [ ] Phase 3: replace straight arrow draw path with routed orthogonal polyline rendering.
- [ ] Phase 4: add/upgrade tests for routing correctness and render-level regression checks.
- [ ] Phase 5: run headful/manual verification for readability and camera behavior parity.
- [ ] Acceptance: all visible dependency links use right-angle grid-following paths with no diagonal trunks.

Phase 1: Geometry and Data Extraction
- Add helper(s) in `game/src/tetris_ui.rs` (or extracted sibling module if needed) to produce:
  - world occupancy set (`HashSet<Vec2i>`) from node shapes
  - node boundary/perimeter candidates per node
  - stable world->screen center conversion for routed points
- Add deterministic ordering helpers:
  - node iteration by id/index
  - neighbor expansion order (`Right, Up, Left, Down` or similar fixed order)
- Keep this phase draw-behavior neutral (helpers only).

Phase 2: Orthogonal Router
- Implement a pure routing function, for example:
  - `route_skill_link(world_start_port, world_end_port, occupancy, bounds, existing_routes) -> Vec<Vec2i>`
- Router characteristics:
  - 4-directional movement only
  - Manhattan heuristic
  - turn penalty when direction changes
  - optional overlap penalty against previously accepted routes
- Bounds policy:
  - route inside `skilltree_world_bounds(def)` with configurable pad margin
  - prevent unbounded searches on sparse maps
- Determinism policy:
  - fixed tie-break ordering
  - fixed edge processing order

Phase 3: Rendering Integration
- Update `draw_skilltree_links(...)` to:
  - compute routes in world coords for each dependency edge
  - convert route points to screen-space centers using current camera/grid transform
  - draw each segment as axis-aligned thick line/rect spans
- Replace vector arrowhead with orthogonal arrow cap aligned to final segment direction.
- Preserve existing color/thickness constants unless a readability issue requires a small tuning pass.
- Keep clipping behavior safe (reuse existing `fill_rect_i32` clipping approach).

Phase 4: Tests
- Add routing unit tests (pure logic):
  - returns only orthogonal adjacent steps
  - avoids occupied node cells
  - deterministic output for same input
  - handles no-route scenario with documented fallback behavior
- Update/extend render tests in `game/tests/tetris_ui_tests.rs`:
  - keep "link pixels are drawn" assertion
  - add a targeted test fixture with known node layout and sampled expected orth segments
  - verify routed links still appear under non-default camera pan/zoom

Phase 5: Manual Verification
- Run skilltree in headful and verify:
  - links remain visually attached to intended source/target nodes
  - links stay orthogonal while panning/zooming
  - dense areas remain readable (no major visual glitches/flicker)
- Verify editor workflows remain unchanged:
  - select/move/add/remove/link tools
  - save/reload definitions

Acceptance Criteria
- Skill dependency links are rendered as right-angle, grid-following paths (no direct diagonal trunk rendering).
- Routing is deterministic and stable across frames/camera movement.
- No regressions to skilltree input behavior or purchase flow.
- New/updated tests cover routing core behavior and render integration.

Risks and Mitigations
- Risk: heavily connected nodes produce cluttered overlaps.
  - Mitigation: add overlap penalty and deterministic lane preference; tune penalties with a dense fixture.
- Risk: pathfinding cost spikes on large layouts.
  - Mitigation: bounded search region + lightweight caches keyed by `(source_id, target_id, camera-independent world layout hash)`.
- Risk: fallback routes look awkward in blocked layouts.
  - Mitigation: codify and test fallback priority rules; log/debug-flag problematic edges during iteration.

Future Extensions
- Optional JSON-authored routing hints (preferred side/waypoints) per edge.
- Optional editor tool for hand-authoring edge waypoints.
- Route post-processing for shared trunk bundling and clearer branch separation.
