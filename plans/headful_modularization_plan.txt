Headful Runtime Modularization Plan
===================================

Plan-ID: HEADFUL_MODULARIZATION_PLAN
Depends-On: INPUT_FRAMEWORK_ENGINE_MIGRATION_PLAN

Status
- Current: IN_PROGRESS
- Last Reviewed: 2026-02-14
- Notes: `game/src/headful/` module tree now exists and major extraction is landed; `headful/main.rs` is reduced but still contains substantial orchestration + gameplay branch logic.

Goal
- Split `game/src/bin/headful.rs` into focused modules to reduce regression risk and improve iteration speed.
- Keep behavior unchanged while improving code ownership boundaries.
- Leave `headful.rs` as thin orchestration and bootstrapping code.

Dependencies
- Run after `plans/input_framework_engine_migration_plan.txt` to avoid extracting input paths that are about to be deleted.
- Coordinate with `plans/performance_budget_hud_profiler_plan.txt` for render/profiling code extraction boundaries.

Non-Goals
- No gameplay redesign in this effort.
- No major rendering feature additions during extraction.
- No broad API churn across unrelated crates.

Target Module Layout
- Add new library module tree under `game/src/headful/`:
  - `input_adapter.rs` (frame input to domain intent; no raw window event parsing)
  - `view_transitions.rs` (menu/pause/game-over/skilltree transition logic)
  - `skilltree_camera.rs` (pan/zoom/drag state machine and bounds clamp glue)
  - `render_pipeline.rs` (scene ordering, overlay composition, layout cache handling)
  - `mod.rs` (public module wiring)
- Keep `game/src/bin/headful.rs` responsibilities:
  - CLI parsing and run-mode selection
  - app startup wiring
  - high-level app struct composition

Design Rules
- Extract by behavior-preserving slices, not by large rewrites.
- Prefer moving pure functions first, then stateful code.
- Keep every step compiling and testable.
- Keep new module APIs narrow and explicit.

Execution Checklist
- [x] Phase 1: capture baseline parity and add any missing high-risk tests. (Done 2026-02-14: baseline `cargo test -p game --bin headful`; added focused module tests in `headful/input_adapter.rs`, `headful/view_transitions.rs`, and `headful/skilltree_camera.rs`; verified with `cargo test -p game`.)
- [x] Phase 2: scaffold `game/src/headful/` module files and API boundaries. (Done 2026-02-14: added `mod.rs`, `input_adapter.rs`, `view_transitions.rs`, `skilltree_camera.rs`, `render_pipeline.rs`; wired `pub mod headful;` in `game/src/lib.rs`.)
- [x] Phase 3: extract pure helpers/constants with behavior-preserving wrappers. (Done 2026-02-14: moved key mapping/action-sfx, view transition/result helpers, and camera mapping/bounds helpers into dedicated modules; kept wrapper callsites in `headful/main.rs`.)
- [x] Phase 4: extract stateful subsystems (skilltree camera, transitions, input adapter). (Done 2026-02-14: extracted horizontal repeat/input-frame adaptation, view-event transition application helpers, and skilltree drag/zoom/edge-pan/finalize camera behavior into `game/src/headful/*` modules.)
- [x] Phase 5: extract rendering orchestration to `render_pipeline.rs`. (Done 2026-02-14: moved render draw ordering/overlay/layout-cache orchestration into `game/src/headful/render_pipeline.rs`; `headful/main.rs::render` now delegates.)
- [ ] Phase 6: reduce `headful.rs` to orchestration-only flow. (Remaining: `process_keyboard_frame`, `update_state` UI/editor match branches, and remote command handling still contain large control-flow blocks in `game/src/bin/headful/main.rs`.)
- [ ] Phase 7: run test/manual parity passes for controls, drag/zoom, menus, and debug HUD. (Blocked for manual pass in this environment: no interactive windowed session run captured in this execution; automated parity/tests completed via `cargo test -p game`.)
- [ ] Acceptance: dedicated modules own behavior while runtime behavior remains unchanged. (Pending completion of Phase 6 + manual parity pass in Phase 7.)

Phase 1: Baseline and Safety Net
- Capture baseline behavior with existing tests and quick manual smoke checks:
  - menu transitions
  - tetris controls
  - skilltree camera interactions
  - debug HUD overlay
- Add missing focused tests before moving high-risk logic blocks.

Phase 2: Create Module Scaffolding
- Add `game/src/headful/mod.rs` and empty module files.
- Introduce minimal public API boundaries (types and function signatures only).
- Wire `game/src/lib.rs` exports if needed for tests and shared use.

Phase 3: Extract Pure Logic First
- Move pure helper functions/constants from `headful.rs` into:
  - view transition helpers
  - key-to-action mapping helpers
  - render-order helper functions
- Keep call sites stable with temporary passthrough wrappers where useful.

Phase 4: Extract Stateful Subsystems
- Skilltree camera subsystem:
  - drag threshold, drag update, bounds clamp glue
  - edge-pan and wheel-zoom helpers
- View transition subsystem:
  - centralize view/event transition handling
  - keep side effects (sfx, reset hooks) explicit
- Input adapter subsystem:
  - consume `InputFrame` and produce per-frame gameplay/view intents

Phase 5: Extract Rendering Orchestration
- Move scene draw ordering and layout cache orchestration into `render_pipeline.rs`.
- Keep draw calls and profiling hooks grouped in one place.
- Preserve exact draw order and overlay semantics.

Phase 6: Shrink and Harden `headful.rs`
- Remove migrated helper/state branches from `headful.rs`.
- Keep only orchestration code and module invocations.
- Target readability goals:
  - significantly lower line count
  - fewer large nested match blocks

Phase 7: Verification
- Run game and engine tests touched by extraction.
- Add focused module tests where logic is now isolated.
- Manual parity pass for:
  - controls and repeat behavior
  - skilltree drag and zoom
  - menu and pause flows
  - debug HUD visibility/toggle behavior

Acceptance Criteria
- `headful.rs` is reduced to orchestration-focused responsibilities.
- Input adaptation, view transitions, skilltree camera behavior, and render orchestration live in dedicated modules.
- No behavior regressions in gameplay/UI flow compared to baseline.
- New module boundaries are clear enough for future feature work.

Risks and Mitigations
- Risk: extraction mixes refactor with feature changes and causes regressions.
  - Mitigation: enforce behavior-preserving slices and parity checks each phase.
- Risk: cyclic dependencies between extracted modules.
  - Mitigation: keep shared data in small explicit interfaces and avoid bidirectional module calls.
- Risk: large moves become hard to review.
  - Mitigation: split into small commits/PR slices by subsystem.
