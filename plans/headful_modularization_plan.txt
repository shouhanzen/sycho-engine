Headful Runtime Modularization Plan
===================================

Status
- Current: NOT_STARTED
- Last Reviewed: 2026-02-14
- Notes: No `game/src/headful/` module tree exists yet; extraction work has not started.

Goal
- Split `game/src/bin/headful.rs` into focused modules to reduce regression risk and improve iteration speed.
- Keep behavior unchanged while improving code ownership boundaries.
- Leave `headful.rs` as thin orchestration and bootstrapping code.

Dependencies
- Run after `plans/input_framework_engine_migration_plan.txt` to avoid extracting input paths that are about to be deleted.
- Coordinate with `plans/performance_budget_hud_profiler_plan.txt` for render/profiling code extraction boundaries.

Non-Goals
- No gameplay redesign in this effort.
- No major rendering feature additions during extraction.
- No broad API churn across unrelated crates.

Target Module Layout
- Add new library module tree under `game/src/headful/`:
  - `input_adapter.rs` (frame input to domain intent; no raw window event parsing)
  - `view_transitions.rs` (menu/pause/game-over/skilltree transition logic)
  - `skilltree_camera.rs` (pan/zoom/drag state machine and bounds clamp glue)
  - `render_pipeline.rs` (scene ordering, overlay composition, layout cache handling)
  - `mod.rs` (public module wiring)
- Keep `game/src/bin/headful.rs` responsibilities:
  - CLI parsing and run-mode selection
  - app startup wiring
  - high-level app struct composition

Design Rules
- Extract by behavior-preserving slices, not by large rewrites.
- Prefer moving pure functions first, then stateful code.
- Keep every step compiling and testable.
- Keep new module APIs narrow and explicit.

Phase 1: Baseline and Safety Net
- Capture baseline behavior with existing tests and quick manual smoke checks:
  - menu transitions
  - tetris controls
  - skilltree camera interactions
  - debug HUD overlay
- Add missing focused tests before moving high-risk logic blocks.

Phase 2: Create Module Scaffolding
- Add `game/src/headful/mod.rs` and empty module files.
- Introduce minimal public API boundaries (types and function signatures only).
- Wire `game/src/lib.rs` exports if needed for tests and shared use.

Phase 3: Extract Pure Logic First
- Move pure helper functions/constants from `headful.rs` into:
  - view transition helpers
  - key-to-action mapping helpers
  - render-order helper functions
- Keep call sites stable with temporary passthrough wrappers where useful.

Phase 4: Extract Stateful Subsystems
- Skilltree camera subsystem:
  - drag threshold, drag update, bounds clamp glue
  - edge-pan and wheel-zoom helpers
- View transition subsystem:
  - centralize view/event transition handling
  - keep side effects (sfx, reset hooks) explicit
- Input adapter subsystem:
  - consume `InputFrame` and produce per-frame gameplay/view intents

Phase 5: Extract Rendering Orchestration
- Move scene draw ordering and layout cache orchestration into `render_pipeline.rs`.
- Keep draw calls and profiling hooks grouped in one place.
- Preserve exact draw order and overlay semantics.

Phase 6: Shrink and Harden `headful.rs`
- Remove migrated helper/state branches from `headful.rs`.
- Keep only orchestration code and module invocations.
- Target readability goals:
  - significantly lower line count
  - fewer large nested match blocks

Phase 7: Verification
- Run game and engine tests touched by extraction.
- Add focused module tests where logic is now isolated.
- Manual parity pass for:
  - controls and repeat behavior
  - skilltree drag and zoom
  - menu and pause flows
  - debug HUD visibility/toggle behavior

Acceptance Criteria
- `headful.rs` is reduced to orchestration-focused responsibilities.
- Input adaptation, view transitions, skilltree camera behavior, and render orchestration live in dedicated modules.
- No behavior regressions in gameplay/UI flow compared to baseline.
- New module boundaries are clear enough for future feature work.

Risks and Mitigations
- Risk: extraction mixes refactor with feature changes and causes regressions.
  - Mitigation: enforce behavior-preserving slices and parity checks each phase.
- Risk: cyclic dependencies between extracted modules.
  - Mitigation: keep shared data in small explicit interfaces and avoid bidirectional module calls.
- Risk: large moves become hard to review.
  - Mitigation: split into small commits/PR slices by subsystem.
