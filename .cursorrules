Signature Techniques (Process)

Plan
- Feature First: for any change, implement the feature/fix first, then write or update tests to lock the behavior in.
- When debugging, start from a clear reproduction (manual steps, logs, or a minimal script); add tests after the fix to prevent regressions.

Act
- Implement only the smallest change needed to satisfy the desired behavior.
- Keep the diff tight and incremental; refactor only as needed to support the change.

Verify
- After the feature/fix works, write or update tests that capture the behavior.
- When adding or updating tests, run them automatically after writing them.

Control Surface
- Use the `go.sh` script to control program execution.
- Prefer flags like `--start`, `--stop`, `--status` (and related flags) to manage lifecycle.
- `--start` runs in the foreground by default; use `--detach` for background (pid/log-managed) runs.
- Use `--stop` to stop background processes started via `--start --detach`.
- This is the standard agent control surface; use it instead of ad-hoc commands.

Stability
- If the project mysteriously doesn't run after other agents' changes, wait 1 minute and then retry.

Architecture (Workspace + Layering)
- Workspace crates:
  - `engine/`: reusable core systems and primitives.
  - `game/`: gameplay/runtime composition that depends on `engine`.
  - `editor/frontend/src-tauri/`: editor app shell/tools (Tauri), separate from gameplay runtime.
- Dependency direction must remain one-way for shared runtime logic:
  - `engine` is the foundation.
  - `game` consumes `engine`.
  - `editor` should integrate via stable engine-facing data/contracts where applicable, not by re-implementing engine internals.

Engine-First Feature Development
- If a feature is engine-level (rendering primitives, core simulation rules, shared data model, deterministic utilities, cross-app runtime behavior), implement it in `engine` first.
- Expose the feature through clean `engine` APIs/types, then adopt it from `game` (and `editor` when relevant).
- Do not land engine-level behavior directly in `game` if it belongs in `engine`; move/refactor it into `engine` first, then wire usage in `game`.
- Keep `game` focused on orchestration, product-specific behavior, and app/runtime integration.
- When adding engine features, include/update engine tests first; then add/update game-level integration tests where behavior crosses crate boundaries.
