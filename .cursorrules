Signature Techniques (Process)

Plan
- Feature First: for any change, implement the feature/fix first, then write or update tests to lock the behavior in.
- When debugging, start from a clear reproduction (manual steps, logs, or a minimal script); add tests after the fix to prevent regressions.

Act
- Implement only the smallest change needed to satisfy the desired behavior.
- Keep the diff tight and incremental; refactor only as needed to support the change.

Verify
- After the feature/fix works, write or update tests that capture the behavior.
- When adding or updating tests, run them automatically after writing them.

Control Surface
- Use the `go.sh` script to control program execution.
- Prefer flags like `--start`, `--stop`, `--status` (and related flags) to manage lifecycle.
- `--start` runs in the foreground by default; use `--detach` for background (pid/log-managed) runs.
- Use `--stop` to stop background processes started via `--start --detach`.
- This is the standard agent control surface; use it instead of ad-hoc commands.

Stability
- If the project mysteriously doesn't run after other agents' changes, wait 1 minute and then retry.

Architecture (Workspace + Layering)
- Workspace crates:
  - `engine/`: reusable core systems and primitives.
  - `game/`: gameplay/runtime composition that depends on `engine`.
  - `editor/frontend/src-tauri/`: editor app shell/tools (Tauri), separate from gameplay runtime.
- Dependency direction must remain one-way for shared runtime logic:
  - `engine` is the foundation.
  - `game` consumes `engine`.
  - `editor` should integrate via stable engine-facing data/contracts where applicable, not by re-implementing engine internals.

Engine-First Feature Development
- If a feature is engine-level (rendering primitives, core simulation rules, shared data model, deterministic utilities, cross-app runtime behavior), implement it in `engine` first.
- Expose the feature through clean `engine` APIs/types, then adopt it from `game` (and `editor` when relevant).
- Do not land engine-level behavior directly in `game` if it belongs in `engine`; move/refactor it into `engine` first, then wire usage in `game`.
- Keep `game` focused on orchestration, product-specific behavior, and app/runtime integration.
- When adding engine features, include/update engine tests first; then add/update game-level integration tests where behavior crosses crate boundaries.

Planning (Lightweight PlanTree)
- Keep planning in Markdown/plaintext files under `plans/`; avoid adding a required CLI workflow unless complexity clearly justifies it.
- Put speculative/ideation/future-thinking docs under `plans/ideas/` so active implementation plans in `plans/` stay unambiguous for agents.
- Treat `plans/ideas/` documents as exploratory notes, not execution-ready plans; only promote/move them into `plans/` once approved for implementation planning.
- Prefer one plan file per initiative with clear sections: Goal, Design Rules/Constraints, Phases, Acceptance Criteria, Future Extensions.
- If a task depends on another task, record it explicitly in the plan text (DAG-style dependencies are encouraged, but keep format simple and human-editable).
- To claim work, add an owner marker and timestamp in the plan entry/phase note; update it as progress is made.
- Mark completed work with a done marker and a short verification note (test command/manual check) near the completed item.
- Use `plans/done/` as the canonical archive location for completed plans.
- When a plan is complete, move it into `plans/done/` (optionally organized by month) so active plans stay focused.
